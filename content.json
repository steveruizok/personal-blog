{"pages":[{"slug":"about","content":"\nMy name is Steve Ruiz and I'm a developer and interaction designer in London, currently working with creative tools. I build lots of prototypes. Sometimes those prototypes turn into products.\n\n## My Work\n\nI'm currently focusing on [tldraw](https://tldraw.com), a white-boarding application and an [engine](https://github.com/tldraw/tldraw) for applications that render React components onto a canvas interface. You can [sponsor my work](https://github.com/sponsors/steveruizok) on Github!\n\nI've previously worked with [Play](https://www.createwithplay.com/), helping to design a mobile-first design application for iOS. Before that, I was creating educational content for [Framer](https://framer.com/) and a user experience architect at [Inviqa](https://inviqa.com/). I've also worked with [ClearScore](https://www.clearscore.com/), [Phenomen Films](https://www.phenomentrust.org/), and plenty of shorter contracts, too.\n\n## Open Source\n\nI maintain a few open source projects:\n\n- [tldraw](https://tldraw.com/) is a tiny little drawing app.\n- [perfect-freehand](https://github.com/steveruizok/perfect-freehand) is a library for drawing freehand lines.\n- [perfect-arrows](https://github.com/steveruizok/perfect-arrows) is a library for drawing arrows between points and shapes. It made for some fun [tweet threads](https://twitter.com/steveruizok/status/1283139008499986437).\n- [state-designer](https://state-designer.com/) is a state management library with its own [visual design environment](https://ide.state-designer.com/). It's based on state charts and is great for prototyping.\n\n## Education\n\nI have my Masters degree in Fine Art from the University of Chicago. If you're curious, you can see more of my artwork [here](https://steveruizart.com).\n\n## Contact\n\nThe best way to contact me is on [twitter](https://twitter.com/steveruizok).\n","data":{"title":"About"},"index":0},{"slug":"archive","content":"","data":{"title":"Archive"},"index":1},{"slug":"index","content":"","data":{},"index":2}],"posts":[{"index":0,"slug":"reordering","content":"\nIn an app that uses a zoom UI, canvas, or really any paradigm where things are \"stacked\" in order from back to front, the user interface will usually provide some commands that let a user move items in the stack:\n\n1. **Send to Back**\n2. **Send Backward**\n3. **Bring Forward**\n4. **Bring to Front**\n\nImplementing these commands will depend on how your application structures its items. Are they in an array? Are they in a table? Is this a multiplayer application?\n\nIn this article, I'll cover the most straightforward implementation in an app that structures its items in an array. In a future post, I'll cover a more complex method in an application where items are stored in a hash table.\n\n## Mise en place\n\nLet's say we have an application where we're storing our items in an array:\n\n```ts\ntype Item = { id: string }\n\ntype Items = Item[]\n\nconst itemsExample: Items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }]\n```\n\nIn this structure, each item's \"order\" is represented by that item's index in the array. In the example above, the item `{ id: \"a\" }` has the index of `0`, the item `{ id: \"b\" }` has the index of `1`, etc.\n\nNow that we have our data worked out, let's look at how we would implement our four reordering commands.\n\n> ðŸš€ You can view the code and tests for this post at this [CodeSandbox](https://codesandbox.io/s/silly-proskuriakova-clnlk?file=/src/array-ordering.test.ts).\n\n### Send to Back\n\n```ts\nfunction sendToBack(items: Item[], ids: string[]) {\n  const movingIds = new Set(ids)\n  const moving: Item[] = []\n  const notMoving: Item[] = []\n  for (const item of items) {\n    const arr = movingIds.has(item.id) ? moving : notMoving\n    arr.push(item)\n  }\n  return moving.concat(notMoving)\n}\n```\n\nFor `sendToBack`, we would want the new `items` array to be all of the moving items, sorted by their prior order within the `items` array, followed by all of the static items sorted by their prior order in the `items` array.\n\nThis works for single items as well as for multiple items:\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = sendToBack(items, [\"c\"]) // c, a, b, d\n```\n\n<Figure\n  src=\"/images/reordering/send_to_back_1.png\"\n  alt=\"A diagram showing the result of moving c to back in items a, b, c, d.\"\n/>\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = sendToBack(items, [\"b\", \"d\"]) // b, d, a, c\n```\n\n<Figure\n  src=\"/images/reordering/send_to_back_2.png\"\n  alt=\"A diagram showing the result of moving b and d to back in items a, b, c, d.\"\n/>\n\n### Bring to Front\n\n```ts\nfunction bringToFront(items: Item[], ids: string[]) {\n  const movingIds = new Set(ids)\n  const moving: Item[] = []\n  const notMoving: Item[] = []\n  for (const item of items) {\n    const arr = movingIds.has(item.id) ? moving : notMoving\n    arr.push(item)\n  }\n  return notMoving.concat(moving)\n}\n```\n\nFor `bringToFront`, we perform the same work as `sendToBack`, except this time adding the moving items to the end of the static items array. Again, both arrays preserve their items' order from the input array.\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = bringToFront(items, [\"b\"]) // a, c, d, b\n```\n\n<Figure\n  src=\"/images/reordering/bring_to_front.png\"\n  alt=\"A diagram showing the result of moving c to front in items a, b, c, d.\"\n/>\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = bringToFront(items, [\"a\", \"c\"]) // b, d, a, c\n```\n\n<Figure\n  src=\"/images/reordering/bring_to_front_2.png\"\n  alt=\"A diagram showing the result of moving a and c to front in items a, b, c, d.\"\n/>\n\n### Send Backward\n\n```ts\nfunction sendBackward(items: Item[], ids: string[]) {\n  const movingIds = new Set(ids)\n  const indices: number[] = []\n  items.forEach((item, i) => {\n    if (movingIds.has(item.id)) {\n      indices.push(i)\n    }\n  })\n  const result = items.slice()\n  indices.forEach((index) => {\n    const movingItem = result[index]\n    const neighborBelow = result[index - 1]\n    if (neighborBelow && !movingIds.has(neighborBelow.id)) {\n      result[index] = neighborBelow\n      result[index - 1] = movingItem\n    }\n  })\n  return result\n}\n```\n\nSending an item backward is a little more complex. Here we want to iterate through each moving item's original index and try to swap the item we find at that index in the results array with its neighbor at the index below. If there is no neighbor item, then this means we're trying to move the first item in the list; and if the neighbor is also moving, then this means we haven't yet been able to move any items down.\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = sendBackward(items, [\"c\"]) // a, c, b, d\n```\n\n<Figure\n  src=\"/images/reordering/send_backward_1.png\"\n  alt=\"A diagram showing the result of moving c backward in items a, b, c, d.\"\n/>\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = sendBackward(items, [\"b\", \"c\"]) // b, c, a, c\n```\n\n<Figure\n  src=\"/images/reordering/send_backward_4.png\"\n  alt=\"A diagram showing the result of moving b and c backward in items a, b, c, d.\"\n/>\n\n### Bring Forward\n\n```ts\nfunction bringForward(items: Item[], ids: string[]) {\n  const movingIds = new Set(ids)\n  const indices: number[] = []\n  items.forEach((item, i) => {\n    if (movingIds.has(item.id)) {\n      indices.push(i)\n    }\n  })\n  const result = items.slice()\n  indices.reverse().forEach((index) => {\n    const movingItem = result[index]\n    const neighborAbove = result[index + 1]\n    if (neighborAbove && !movingIds.has(neighborAbove.id)) {\n      result[index] = neighborAbove\n      result[index + 1] = movingItem\n    }\n  })\n  return result\n}\n```\n\nThe `bringForward` method is implemented in a similar way, but reversing the indices array so that we iterate down from the highest index to the lowest, and swapping each item with the item above it in the results array.\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = bringForward(items, [\"b\"]) // a, c, b, d\n```\n\n<Figure\n  src=\"/images/reordering/bring_forward_1.png\"\n  alt=\"A diagram showing the result of moving b forward in items a, b, c, d.\"\n/>\n\n```ts\nlet items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }, { id: \"d\" }]\nitems = bringForward(items, [\"b\", \"c\"]) // b, a, d, c\n```\n\n<Figure\n  src=\"/images/reordering/bring_forward_2.png\"\n  alt=\"A diagram showing the result of moving b and c forward in items a, b, c, d.\"\n/>\n\n## Wrapup\n\nMoving items in an array has some upsides and some downsides. An advantage is that items may be placed in the document or painted in the correct order without any further sorting or manipulation.\n\n```tsx\nfor (const item of items) {\n  canvas.paintItem(item)\n}\n```\n\n```tsx\n<div>\n  {items.map((item) => (\n    <Item key={item.id} item={item} />\n  ))}\n</div>\n```\n\nThe main disadvantage comes from the difficulty of accessing a particular item within the array, which requires a search through the array.\n\n```ts\nconst items = [{ id: \"a\" }, { id: \"b\" }, { id: \"c\" }]\n\nfunction getItem(id: string) {\n  return items.find((item) => item.id === id)\n}\n```\n\nThis can be impractical for apps that need to store many items, or that require a more efficient way of accessing items. This is usually done with a hash table (such as a `Map`, or plain object) or another from of associative structure.\n\n```ts\nconst items = {\n  a: { id: \"a\", index: 1 },\n  b: { id: \"b\", index: 2 },\n  c: { id: \"c\", index: 3 },\n}\n\nfunction getItem(id: string) {\n  return items[id]\n}\n```\n\nHowever, while hash tables make for fast lookup, they can't make guarantees about ordering in the same way that arrays do; and so we would be forced to keep track of indices ourselves.\n\nThis adds some new trickiness and I'll cover that in the next post.\n\n> ðŸš€ You can view the code and tests from this post at this [CodeSandbox](https://codesandbox.io/s/silly-proskuriakova-clnlk?file=/src/array-ordering.test.ts).\n\n---\n\nThanks for reading! For more like this, follow me on [Twitter](https://twitter.com). To support my work and nudge me toward more blogging, sponsor me on [Github](https://github.com/sponsors/steveruizok).\n","date":1644537600000,"data":{"title":"Reordering Part 1: Arrays","date":"Friday, 11 February 2022","hero":"/images/reordering/send_to_back_2.png","status":"published","description":"Implementing ordering commands (Send to Back, Send Backward, Bring Forward, and Bring to Front) in an array of items."}},{"index":1,"slug":"dead-zone","content":"\nThis is another post about improving user experience in applications that involve dragging shapes around on a canvas, or in a [zoom-ui](/posts/zoom-ui). This post will cover implementing a \"dead zone\": a minimum distance needed before a shape will begin to drag.\n\nA dead zone is very useful to prevent \"accidental drags\" during clicks. Without a dead zone, a pixel or two of movement can result in a change to a shape's position. This especially common on touch devices or when using a stylus, and it can be very frustrating for users.\n\nBut have no fearâ€”a dead zone can fix it.\n\n> ðŸ‘‹ Just want to look at some code? [Click here](https://codesandbox.io/s/dead-zone-example-1zkw9) for the CodeSandbox.\n\n## Get Your Dragging Right First\n\nThis post is a follow-up to my [post](/posts/perfect-dragging) about the correct way to calculate where a dragging shape should be, by comparing the user's current pointer location with its location when the drag began.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_1.png\"\n  alt=\"A diagram showing how a shape's point is calculated.\"\n  title=\"To find the shape's current point, subtract the pointer's current point and its original point and add the result to the shape's original point.\"\n/>\n\nIn that post, I mentioned that such a technique could be useful for features such as implementing a dead zone; and as we'll see, it fixes plenty of issues with dead zones.\n\n## The Dead Zone FSM\n\nWe can implement a dead zone using a finite state machine with three states: `idle`, `pointing`, and `dragging`.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_4.png\"\n  alt=\"A diagram showing how the relationships between three finite states: idle, pointing, and dragging.\"\n  title=\"The dead zone finite state machine.\"\n/>\n\nThe state machine works like this: A user starts out in the `idle` state. When a user starts pointing a shape, we transition to the `pointing` state.\n\nIn the `pointing` state, a user can either stop pointing and return to the `idle` state, or they can move their pointer. While in the `pointing` state, moving the pointer has no effect on the shape's position. If the user moves their pointer far enough from that it leaves the dead zone, then we transition to the `dragging` state.\n\nWhen we enter the `dragging` state, we update the shape's position and keep updating it whenever the user moves their pointer. From this state, a user can return to the `idle` state by ending their drag.\n\n## Getting it Right\n\nWhile a good drag zone is useful, it's important to implement it correctly. You'll know that an implementation is correct if the user's pointer location in the `dragging` state is the same, relative to the shape, as when the user started pointing the shape.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_5.png\"\n  alt=\"A diagram showing how the position of the pointer after leaving the dead zone.\"\n  title=\"On the left, the pointer is now further up into the upper-right corner; on the right, the pointer is centered in the shape.\"\n/>\n\nAnd here's where our dragging strategy matters.\n\nIf we we only using the difference between the pointer's location and its previous location, then our \"dead zone\" would be the distance of that move; allowing a slow-moving pointer to remain in that dead zone forever.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_8.mp4\"\n  alt=\"A video showing shapes being moved around.\"\n  title=\"Using the pointer event's distance to trigger the dead zone won't work with slow-moving pointers. Bad!\"\n  isVideo\n/>\n\nFurther, once we left the dead zone, we would have no way of putting the shape back where it should be. If we only began offsetting based on pointer movement, the shape will have lagged behind.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_7.mp4\"\n  alt=\"A video showing shapes being moved around.\"\n  title=\"Using the pointer's movement means a shape will lag behind the pointer once it starts dragging. Bad!\"\n  isVideo\n/>\n\nHowever, if we're comparing against the pointer's original location, then the shape will be in the right place no matter where the pointer is when it leaves the dead zone; and we'll always leave the dead zone once it's reached the minimum distance.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_9.mp4\"\n  alt=\"A video showing shapes being moved around.\"\n  title=\"The shape is always placed correctly under the pointer. Good!\"\n  isVideo\n/>\n\n## Why is this better?\n\nAs I wrote at the start of this post, a well-implemented dead zone can prevent accidental drags during clicks, which are especially common on touch devices or when the user is pointing with a stylus. Done right, a dead zone can make an app feel more intentional while being almost impossible to notice.\n\n<Figure\n  src=\"/images/dead-zone/dead_zone_6.mp4\"\n  alt=\"A video showing shapes being moved around.\"\n  title=\"Dead zones are hard to spot unless you're dragging very slowly.\"\n  isVideo\n/>\n\nIn the example aboves, we've used a generous dead zone distance in order to show the feature in action. In a real app, you might set your dead zone as low as two or three pixels: low enough that it will only last a frame or two, but high enough to catch accidental drags.\n\n## Example\n\nWant to see this in practice? Here's an [example](https://codesandbox.io/s/dead-zone-example-1zkw9) in React.\n\n<CodeSandbox url=\"dead-zone-example-1zkw9\" />\n","date":1634770800000,"data":{"title":"Dead Zone Dragging","date":"Thursday, 21 October 2021","hero":"/images/dead-zone/dead_zone_3.png","status":"published","description":"Improve dragging experience by adding a spooky dead zone, or a minimum distance before a shape will begin to drag."}},{"index":2,"slug":"perfect-dragging","content":"\nI recently started writing a post about [snapping](https://twitter.com/steveruizok/status/1449866480401764359) but realized I needed to write a post about dragging first.\n\n<Tweet id=\"1449866480401764359\" />\n\nIn this post, I'm going to quickly cover how to drag a shape on a canvas, or in an application that uses some kind of [zoom ui](/posts/zoom-ui). While it may seem obvious, implementing dragging in the wrong way means that other features, such as snapping, will become much more difficult to implement later on. It's worth getting it right the first time!\n\n> ðŸ‘‹ Just want to look at some code? [Click here](https://codesandbox.io/s/perfect-dragging-example-wg5u6) for the CodeSandbox.\n\n## Picking the Right Delta\n\nWhen a user drags a shape, its our job to calculcate the shape's new position based on whatever browser event we've received. On the web, this is usually a mouse move, touch move, or pointer move; but it could also be a scroll, pan, or zoom event, too.\n\n<Figure src=\"/images/dragging/dragging_3.png\" />\n\nMany applications calculate this new position by finding the pointer's movementâ€”the difference between the pointer's _current_ point and its _previous_ point)â€”and adding this to the shape's current position. While this works, it's a bad idea. :(\n\n<Figure src=\"/images/dragging/dragging_2.png\" />\n\nA far better idea is to calculate the shape's position by taking the pointer's deltaâ€”i.e. the difference between the pointer's _current_ point and the point where the drag _began_. We can then add this delta to the shape's _original_ position in order to find its new position.\n\n<Figure src=\"/images/dragging/dragging_1.png\" />\n\n## Why is this better?\n\nThere are several advantages to this approach:\n\n- You can implement a \"dead zone\" to prevent accidental drags.\n- You can update the position while scrolling during the drag.\n- You can restore a shape's position if the user cancels the drag.\n- You can freely adjust the delta with features like snapping, precision mode, or elastic bounds.\n\nIn later posts, I'll show how you could build these types of features on top of this strategy.\n\nUntil then, you'll have to trust me: in every case, the only way to implement these features is to _never_ rely on the shape's \"current\" position and _always_ compare against the shape's original position instead.\n\n## Example\n\nWant to see this in practice? Here's an [example](https://codesandbox.io/s/perfect-dragging-example-wg5u6) in React.\n\n<CodeSandbox url=\"perfect-dragging-example-wg5u6\" />\n","date":1634684400000,"data":{"title":"Perfect Dragging","date":"Wednesday, 20 October 2021","hero":"/images/dragging/dragging_1.png","status":"published","description":"How to drag shapes the right way. And yes, there is a wrong way! But trust me, this is the right way."}},{"index":3,"slug":"rotating-shapes","content":"\nEver notice in [Figma](https://figma.com) that if you rotate a few shapes and then rotate them back, they'll end up in a different place?\n\n<Figure\n  src=\"/images/rotating-shapes/figma-drift.mp4\"\n  alt=\"A video recorded from Figmashowing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nIt's not just Figma! [Excalidraw](https://excalidraw.com) supports this kind of rotation and has the same issue.\n\n<Figure\n  src=\"/images/rotating-shapes/excalidraw-drift.mp4\"\n  alt=\"A video recorded from Excalidraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\n...and so does my own project, [tldraw](https://tldraw.com), which is where I ran into the issue.\n\n<Figure\n  src=\"/images/rotating-shapes/tldraw-drift.mp4\"\n  alt=\"A video recorded from TLDraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nSide note: most other design tools don't support this kind of rotation. Shapes either rotate around their own centers or inherit rotation from a group. I wish they would though!\n\n<Figure\n  src=\"/images/rotating-shapes/pitch-rotation.mp4\"\n  alt=\"A video recorded from Excalidraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nAnyway, here's what's happening. When you start rotating a selection, you need to pick a point to rotate around. We're all using the average center of the selected shapesâ€”and we keep using this point until you stop rotating.\n\n<Figure\n  src=\"/images/rotating-shapes/center-rotate.mp4\"\n  alt=\"A video showing how selected shapes are rotated around their initial common center point.\"\n  isVideo\n/>\n\nHowever, the rotated shapes probably have a different average center; which means that your second rotation (ie to rotate things back) is pivoting around a different point. And that's what causes the change of position.\n\n<Figure\n  src=\"/images/rotating-shapes/new-centers.mp4\"\n  alt=\"A video showing how the selection's common center point changes when shapes are rotated.\"\n  isVideo\n/>\n\nHonestly, I was extremely glad to find this in Figma and other apps because I was worried it was a bug in my own rotation implementation.\n\nIt is even a bug though? It's weird that rotating a group and then rotating it back doesn't put them back in the same place. Let's fix it!\n\n<Figure\n  src=\"/images/rotating-shapes/tldraw-fixed.mp4\"\n  alt=\"A video from the tldraw app showing how the selection's common center point is preserved while the selection does not change.\"\n  isVideo\n/>\n\nAnd here's the fix: once a user starts a rotation, we hold onto the the center point; if the user rotates again, we re-use that same point; and we only give it up once the user makes a new selection.\n\n<Figure\n  src=\"/images/rotating-shapes/canva-fixed.mp4\"\n  alt=\"A video from the Canva app showing how the selection's common center point is preserved while the selection does not change.\"\n  isVideo\n/>\n\nTo their credit, [canva](https://canva.com) seems to be solving the problem is the same way. The original rotation point is preserved until a user makes a new selection.\n\nOk, that's it! Hope you enjoyed this extra-obscure edition of design tool micro-UX. If you catch any rotation-related bugs in [tldraw](https://tldraw.com), let me know!\n\n---\n\nLook familiar? This blog post was adapted from my [Twitter thread](https://twitter.com/steveruizok/status/1439581543480152069).\n\n<Tweet id=\"1439581543480152069\" />\n","date":1632006000000,"data":{"title":"Fixing the Drift in Shape Rotations","date":"Sunday, 19 September 2021","hero":"/images/rotating-shapes/hero.png","status":"published","description":"A look at an obscure bug common to drawing programs, where rotations can cause shapes to move to new positions."}},{"index":4,"slug":"zoom-ui","content":"\nIf you've used apps like Photoshop, Figma, or even Google Maps, then you're probably familiar with a \"zoom UI\". This pattern lets a user explore a \"canvas\" of content by panning around the canvas or zooming in on a specific point.\n\nIn this article, I'll walk through everything involved in implementing the pattern using an infinite canvas. I'll be using TypeScript and React as my example implementations. The concepts are generic and you should be able to apply them to whatever environment, language or framework you like best.\n\n> ðŸ‘‹ Just want to look at some code? [Click here](https://codesandbox.io/s/zoom-ui-example-ep0cf) for the CodeSandbox.\n\n# Core Concepts\n\nLet's start with some core concepts.\n\n![](/images/zoom-ui/camera-viewport-canvas.jpg \"A diagram showing the relationship between the canvas, the camera, and the viewport.\")\n\nThe first is the **canvas**. You can think of this as a fixed plane of infinite dimensions. In a creative app, the canvas holds the user's artboards, shapes or other content.\n\nSuspended in front of this plane is the **camera**. It points at the canvas.\n\nThe **screen** is where we see what the camera sees.\n\nThe **viewport** is the part of the canvas that is visible on the screen.\n\n![](/images/zoom-ui/viewport-screen.jpg \"A diagram showing the relationship between the canvas, the camera, and the viewport.\")\n\nNote that the viewport is not centered around the camera. Instead, the viewport extends _down\nand right_ from the camera.\n\nThe camera can move in three dimensions: the camera's **point** is its position along the horizontal and vertical axes; its **zoom** is its position relative to the canvas. As the camera moves, the viewport will change to reflect the new visible part of the canvas.\n\n## Converting between Screen and Canvas\n\nA zoom UI has two coordinate systems: **screen coordinates** and **canvas coordinates**. A certain point on the screen will always refer to a certain point on the canvas. The actual canvas point will depend on the camera's point and zoom.\n\nIf we model a point like this:\n\n```ts\ninterface Point {\n  x: number\n  y: number\n}\n```\n\nAnd our camera like this:\n\n```ts\ninterface Camera {\n  x: number\n  y: number\n  z: number\n}\n```\n\nThen we can turn a screen point into a canvas point like this:\n\n```ts\nfunction screenToCanvas(point: Point, camera: Camera): Point {\n  return {\n    x: point.x / camera.z - camera.x,\n    y: point.y / camera.z - camera.y,\n  }\n}\n```\n\nAnd likewise, we can turn a canvas point into a screen point:\n\n```ts\nfunction canvasToScreen(point: Point, camera: Camera): Point {\n  return {\n    x: (point.x + camera.x) * camera.z,\n    y: (point.y + camera.y) * camera.z,\n  }\n}\n```\n\n**Note**: In our model, a zoom of `1` is equal to a 100% zoom.\n\n## Finding the Viewport\n\nThe viewport is a box that represents which part of the canvas is shown on the screen. Its values refer to canvas points. To find the viewport, we construct a box by converting the upper left and bottom right points of the screen into their corresponding canvas points.\n\nIf we define a box as:\n\n```ts\ninterface Box {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n}\n```\n\nThen we can find our viewport box like this:\n\n```ts\nfunction getViewport(camera: Camera, box: Box): Box {\n  const topLeft = screenToCanvas({ x: box.minX, y: box.minY }, camera)\n  const bottomRight = screenToCanvas({ x: box.maxX, y: box.maxY }, camera)\n\n  return {\n    minX: topLeft.x,\n    minY: topLeft.y,\n    maxX: bottomRight.x,\n    maxY: bottomRight.y,\n    height: bottomRight.x - topLeft.x,\n    width: bottomRight.y - topLeft.y,\n  }\n}\n```\n\nIn a full screen browser app, we could find the viewport like this:\n\n```ts\nconst viewport = getViewport(camera, {\n  minX: 0,\n  minY: 0,\n  maxX: window.innerWidth,\n  maxY: window.innerHeight,\n  width: window.innerWidth,\n  height: window.innerHeight,\n})\n```\n\nOr, if our canvas was part of a webpage, we could find the viewport using its `DOMRect`. Note that in this case, scrolling would change the \"screen box\".\n\n```ts\nconst rect = document.body.getBoundingClientRect()\n\nconst viewport = getViewport(camera, {\n  minX: rect.left,\n  minY: rect.top,\n  maxX: rect.right,\n  maxY: rect.bottom,\n  width: rect.width,\n  height: rect.height,\n})\n```\n\n## Panning and Zooming\n\nWhen the camera moves along the horizontal or vertical axes, we call this movement a \"pan\". To model a pan, we adjust the camera's point by the delta in either direction. And to make the pan feel consistent, we divide the deltas by the camera's zoom.\n\n```ts\nfunction panCamera(camera: Camera, dx: number, dy: number): Camera {\n  return {\n    x: camera.x - dx / camera.z,\n    y: camera.y - dy / camera.z,\n    z: camera.z,\n  }\n}\n```\n\nWhen the camera moves toward or away from the canvas, we call this movement a \"zoom\". In our model, we also need to provide a canvas point that the camera is \"zooming toward\". Again, to make our zoom feel consistent, we adjust the zoom delta based on the current zoom.\n\n```ts\nfunction zoomCamera(camera: Camera, point: Point, dz: number): Camera {\n  const zoom = camera.z - dz * camera.z\n\n  const p1 = screenToCanvas(point, camera)\n\n  const p2 = screenToCanvas(point, { ...camera, z: zoom })\n\n  return {\n    x: camera.x + (p2.x - p1.x),\n    y: camera.y + (p2.y - p1.y),\n    z: zoom,\n  }\n}\n```\n\n## Capturing Events\n\nIn the browser, both zoom and pan events come from wheel events. By convention, we use the control key to identify a zoom. A user's device will sometimes follow this convention automatically: for example, on a MacBook trackpad, pinching will fire a WheelEvent with `ctrlKey: true`.\n\n```ts\nfunction handleWheel(event: WheelEvent) {\n  event.preventDefault()\n\n  const { clientX: x, clientY: y, deltaX, deltaY, ctrlKey } = event\n\n  if (ctrlKey) {\n    setCamera((camera) => zoomCamera(camera, { x, y }, deltaY / 100))\n  } else {\n    setCamera((camera) => panCamera(camera, deltaX, deltaY))\n  }\n}\n```\n\nSet this event on the `document.body` or the zoom UI's root container.\n\n> In the browser, wheel events often cause other changes such as scrolls or browser-level zooms. Calling `event.preventDefault()` prevents these actions. On mobile devices, you may need to cancel other touch or gesture events to avoid native behaviors.\n\nIn a React app, you might use a hook like this:\n\n```tsx\nReact.useEffect(() => {\n  const elm = ref.current\n\n  if (!elm) return\n\n  elm.addEventListener(\"wheel\", handleWheel, { passive: false })\n\n  return () => elm.removeEventListener(\"wheel\", handleWheel)\n}, [ref])\n```\n\n## Shortcuts\n\nOften you'll also want to have shortcuts for zooming in and out toward the center of the viewport.\n\n```ts\nfunction zoomCameraTo(camera: Camera, point: Point, zoom: number): Camera {\n  const p1 = screenToCanvas(point, camera)\n\n  const p2 = screenToCanvas(point, { ...camera, z: zoom })\n\n  return {\n    x: camera.x + (p2.x - p1.x),\n    y: camera.y + (p2.y - p1.y),\n    z: zoom,\n  }\n}\n```\n\nTo zoom in increments of 25%:\n\n```ts\nfunction zoomIn(camera: Camera): Camera {\n  const i = Math.round(camera.z * 100) / 25\n\n  const nextZoom = (i + 1) * 0.25\n\n  const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 }\n\n  return zoomCameraTo(camera, center, camera.z - nextZoom)\n}\n```\n\n```ts\nfunction zoomOut(camera: Camera): Camera {\n  const i = Math.round(camera.z * 100) / 25\n\n  const nextZoom = (i - 1) * 0.25\n\n  const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 }\n\n  return zoomCameraTo(camera, center, camera.z - nextZoom)\n}\n```\n\nAnd to reset the zoom:\n\n```ts\nfunction resetZoom(camera: Camera): Camera {\n  return zoomCamera(camera, center, camera.z - 1)\n}\n```\n\n## Applying the Camera\n\nIn the browser, the best way to apply a zoom is through CSS transforms.\n\n```ts\nconst transform = `\n  scale(${camera.z}) \n  translate(${camera.x}px, ${camera.y}px)\n`\n```\n\n> Remember that _order matters_ when writing a transform. In this case, the order is: first scale, then translate.\n\nIf you're using canvas, then you can translate the canvas instead.\n\n```ts\nctx.scale(camera.z, camera.z)\nctx.translate(camera.x, camera.y)\n```\n\n## Conclusion\n\nThat's the basics of a zoom UI. Many zoom UIs will also have the option to zooming to content or to selected content, but those functions will be different depending on how the rest of your app is set up.\n\nHere's a [CodeSandbox](https://codesandbox.io/s/zoom-ui-example-ep0cf) showing an SVG implementation for all of the code in this article.\n\nHere's a [CodeSandbox](https://codesandbox.io/s/zoom-ui-example-canvas-6j3wo) showing the same implementation with HTML canvas.\n\nEnjoy!\n","date":1628118000000,"data":{"title":"Creating a Zoom UI","date":"Thursday, 5 August 2021","hero":"/images/zoom-ui/brazil-topno-qvLhmpWIA2Y-unsplash.jpg","status":"published","description":"All the code you need to control a camera in a zoom-able, pan-able UI for an infinite canvas."}},{"index":5,"slug":"how-to-filter-an-object","content":"\nEver need to filter properties from an object? Here's how to do it.\n\nIn JavaScript:\n\n```js\nfunction filterObject(obj, fn) {\n  return Object.fromEntries(Object.entries(obj).filter(fn))\n}\n```\n\nIt's a bit trickier in TypeScript:\n\n```ts\ntype Entry<T> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T]\n\nfunction filterObject<T extends object>(\n  obj: T,\n  fn: (entry: Entry<T>, i: number, arr: Entry<T>[]) => boolean\n) {\n  return Object.fromEntries(\n    (Object.entries(obj) as Entry<T>[]).filter(fn)\n  ) as Partial<T>\n}\n```\n\nIn either case, we can use our `filterObject` helper to return a new copy of an object with certain keys removed. Our filter function works just like `Array.filter`, except that its callback function's first parameter will be the property's key value pair as array (`[key, value]`).\n\n```ts\nconst author = { name: \"Steve\", age: 93, height: 241 }\n\nconst onlySteves = filterObject(author, ([k, v]) => v === \"Steve\")\n// { name: \"Steve\" }\n\nconst onlyNumbers = filterObject(author, ([k, v]) => typeof v === \"number\")\n// { age: 93, height: 241 }\n\nconst onlyNames = filterObject(author, ([k, v]) => k === \"name\")\n// { name: \"Steve\" }\n```\n\n### Older Browsers\n\nIf you wanted to do this by hand (or perhaps in older browsers without polyfills for `Object.fromEntries` and `Object.entries`), you could also do it this way: create a shallow copy of the object, iterate once to generating the entries, and then iterate again to `delete` filtered properties.\n\n```ts\nfunction filterObject2<T extends object>(\n  obj: T,\n  fn: (entry: Entry<T>, i: number, arr: Entry<T>[]) => boolean\n): Partial<T> {\n  const next = { ...obj }\n\n  const entries: Entry<T>[] = []\n\n  for (const key in obj) {\n    entries.push([key, obj[key]])\n  }\n\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (!fn(entry, i, entries)) {\n      delete next[entry[0]]\n    }\n  }\n\n  return next\n}\n```\n\nEnjoy!\n","date":1627945200000,"data":{"title":"Filtering an Object in TypeScript","date":"Tuesday, 3 August 2021","hero":"/images/stephanie-leblanc-JLMEZxBcXCU-unsplash.jpg","status":"published","description":"How to filter properties from an object."}},{"index":6,"slug":"it-wasnt-made-to-do-that","content":"\nThis week [Figma](https://figma.com) launched their [Interactive Components ](https://help.figma.com/hc/en-us/articles/360061175334-Create-interactive-components-with-Variants) feature in beta. The response from the design community has been uh, surprising.\n\n<Tweet id=\"1367501450683834372\" />\n\nThe feature was probably designed with problems like these in mind:\n\n<Tweet id=\"1366830065468768261\" />\n\nThat hasn't stopped designers from filling my timeline with incredible, bizarre prototypes like this:\n\n<Tweet id=\"1366677421001502721\" />\n\n...and this:\n\n<Tweet id=\"1366041396092755970\" />\n\n...and even this:\n\n<Tweet id=\"1366520489578016775\" />\n\nPrototypes like these beg the question... why?\n\nOr, more specifically, **why make this in Figma?**\n\nPersonally, I'm a big fan of making stuff with the wrong tools. Projects like [Poom](https://freds72.itch.io/poom) inspire me. A long time ago, I made a kind of [Minecraft game in Framer](https://framer.cloud/TDhUi/).\n\nPushing constraints and building wild prototypes is fun, but Figma is a special case because its prototypes don't work like anything else. To learn more about why these new protoypes are exciting (or ridiculous, depending on your perspective) let's go back and look at how we got here.\n\n## Draw a Noodle\n\nIn 2017, Figma [released](https://www.figma.com/blog/figma-2-0-now-with-prototyping-and-developer-handoff/) its first set of prototyping features. It worked like this: select Frame A, draw an arrow to Frame B; and then in the preview mode, interact with Frame A to transition to Frame B.\n\n![Drawing a Noodle in Figma](/images/figma-noodle.gif)\n\nWhile the team has continued adding to this part of the app, it hasn't changed much. Prototyping in Figma has always been about **creating links between Frames**.\n\nIn fall of 2020, Figma released [Component Variants](https://www.figma.com/best-practices/creating-and-organizing-Variants/), a new feature that lets a designer create related snapshots of a Component.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-0.png\"\n  alt=\"Component Variants in Figma.\"\n/>\n\nInteractive Components brings prototyping to Component Variants, allowing a designer to **create links between Variants**.\n\n<Figure\n  src=\"/images/figma-interaction.gif\"\n  alt=\"Drawing a link between component Variants.\"\n/>\n\nIt works pretty much the same way: select Variant A, draw an arrow to Variant B; and then in the preview mode, interact with Variant A to transition _the Component_ to Variant B.\n\nTo learn why this change matters so much, let's first look at some of the problems with Figma's prototyping model.\n\n## Noodle Problems\n\nFigma's prototyping model was always good for simple click-through prototypes but it struggled with anything complex. This is because, before Interactive Components, Figma's prototype only kept track of the user's current Frame.[^1]\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-0.svg\"\n  alt=\"A diagram showing three Frames in Figma, with Home as the current Frame.\"\n/>\n\nClicking a link would change the current Frame.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-1.svg\"\n  alt=\"A diagram a link to News, with News as the new current Frame.\"\n/>\n\nAnd that was pretty much it. Building a prototype like this was easy to learn and easy to use. But it had two problems.\n\n### Problem 1: Lots of Noodles\n\nEven a small prototype has lots of links, each of which would need to be created by hand.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-2.svg\"\n  alt=\"A diagram showing all of the possible links.\"\n/>\n\nThere were some tricks to reduce the number of links, such as using the \"Back\" transition target or setting your links on a Component and then reusing that Component between Frames, but there was really no escaping it: prototyping in Figma meant drawing lots and lots of arrows.\n\nAnd while [I really like drawing arrows](https://github.com/steveruizok/perfect-arrows), needing to draw so many arrows made it extremely tedious to prototype even a medium-sized project in Figma.\n\n### Problem 2: Compound Noodles\n\nThere was a bigger problem, however.\n\nReal apps keep track of lots of information that describes the current \"state\" of the app. Navigation is often only a small part of that state. An app's state might also hold information such as the current user's name, their preferences and settings, or the contents of their shopping cart.\n\nBy comparison, a Figma prototype's state included _one_ piece of information: the user's current Frame.\n\nThis meant that a designer looking to model _other_ types of state, such as whether the user is in a \"light mode\" or \"dark mode\", would have to somehow achieve this complexity with only that single property to work with.\n\nThe solution? **Create a Frame for every possible state combination**.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-0.svg\"\n  alt=\"A diagram showing six Frames: three for light mode and three for dark mode.\"\n/>\n\nOnce a designer had modeled each state as its own Frame, a user could \"change the state\" by linking to a version that showed the correct configuration.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-1.svg\"\n  alt=\"A diagram showing six Frames: three for light mode and three for dark mode.\"\n/>\n\nAs you can imagine, this doesn't mix well with the first problem.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-2.svg\"\n  alt=\"A diagram showing 18 arrows between the six Frames.\"\n/>\n\nDifferent _kinds_ of state could make the problem even worse.\n\nAdding a \"dusk\" mode would require yet another duplication, or three more Frames, which is bad enough. But adding a _parallel_ state, such as \"logged in\", would mean duplicating the entire collectionâ€”so six more states on top of the original six, with even more arrows for each.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-3.svg\"\n  alt=\"A diagram showing 18 arrows between the six Frames.\"\n/>\n\nGiven enough time and coffee, I could in theory prototype a working game of checkers in Figma using only links between Framesâ€”but it would require about 500 quintillion Frames to do it, and an even greater number of links.\n\nMore realistically, once I'd built a medium-sized prototype with both light mode, dark mode, and an authentication state, I would never again change that design. Whatever I'd wired up would ship, sorry.\n\n### Enter Interactive Components\n\nGiving each Component its own state means freeing that \"current Frame\" state from its extra duties, greatly reducing the number of Frames needed to model states other than the user's actual navigation.\n\nWhile [@mingyaaa](https://twitter.com/mingyaaa)'s [game of Go](https://www.figma.com/community/file/948345806178418685) would previously have required 10<sup>172</sup> Frames (a number far greater than the number of atoms in the universe), Ming-ya could do it with just four Components, each with four Variants and a simple set of links.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-c-0.png\"\n  alt=\"A screenshot of a Figma file showing four Components.\"\n/>\n\nThe fundamental problem hasn't changed: modeling a Component with multiple properties still means creating different Variants for each combination of the Component's properties. However, by pushing the problem down into Components, Interactive Components greatly reduces the number of combinations.\n\nPrototypes that were impossible (or impractical) before are now comparitively easy to put together. That's good for everyone.\n\n## Prototyping Anything?\n\nWhile Figma's Interactive Components do expand the field of what a designer can do in a Figma prototype, there are still some major limitations. Without the ability to store, refer to, or manipulate actual data like text, numbers, or values, designers will be limited to what can be fully represented through snapshots.\n\nFor example, Design XStream's [text input](https://www.figma.com/community/file/949319444934680661) has a \"Single Letter\" Component with Variants for each possible character. The input field is a row of 26 of these components. Pressing a key changes the Component's Variant to match the key that you've pressed.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-d-0.png\"\n  alt=\"A screenshot of the Single Character Component, showing interactions.\"\n/>\n\nIn other words, Figma isn't actually storing the text you type; it's just changing the Variant of each of those Components. There's no way to use that data outside of the component.\n\n## Fun with Prototypes\n\n<Tweet id=\"1367024814062530560\" />\n\nOk, so prototyping in Figma isn't perfect. But as these prototype show, you _can_ do a lot with Interactive Components. While I'll still use other tools for more serious prototyping, Figma's limitations do make for some excellent creative constraints.\n\nInteractive Components might not have been meant to make text inputs or games, but when you give talented people simple tools to use, they can make some pretty amazing things. And I _am_ sure that the feature was made to be funâ€”and in that sense, mission accomplished!\n\n---\n\n[^1] Technically speaking, Figma also keeps track of the user's visited Frames. This \"navigation stack\" works like a stack of cards: clicking a link would add a new Frame to the stack, and going back would remove the current Frame from the stack. Whichever way you went, the Frame on top of the stack would always become the new current Frame.\n","date":1614902400000,"data":{"title":"Figma's Interactive Components Were Not Designed For This","date":"Friday, 5 March 2021","hero":"/images/figma-input.png","status":"published","description":"A survey of the bizarre prototypes designers can now make in Figma."}},{"index":7,"slug":"rotating-icon-button","content":"\nIf you haven't already, try changing the theme on this blog by clicking the button in the top right corner of the webpage. You'll notice a fun detail: as you cycle between the themes, the icons will \"rotate\" in from bottom to top.\n\nKinda cool, right?\n\nIn design, We call these little details _microinteractions_[^1]. Small, surprising and hopefully delightful, these animations can give an outsized amount of character to an otherwise boring, functional user interface.\n\nIn this post, I'll show you how to build a rotating icon button like mine in React. If you're just looking for the code, feel free to skip to the end or [click here](https://codesandbox.io/s/festive-fog-hnnqy?from-embed) for the code sandbox.\n\nOk, let's get started!\n\n## Setup\n\n> If you'd like to follow along, you can fork [this CodeSandbox](https://codesandbox.io/s/intelligent-goldwasser-z9szy?file=/src/App.js).\n\nLet's start by creating a new React app and adding our dependencies. For this article, I'll be using `styled-components` to handle styling and `react-feather` for icons. I'm going to use three icons: `Sun`, `CloudRain`, and `Moon`.\n\nWe'll also need a component for our button, `RotatingIconButton`. Our app is going to return this button with our three icons as its children.\n\n```jsx\nimport React from \"react\"\nimport { Sun, CloudRain, Moon } from \"react-feather\"\nimport styled from \"styled-components\"\n\nexport default function App() {\n  return (\n    <RotatingIconButton>\n      <Sun />\n      <CloudRain />\n      <Moon />\n    </RotatingIconButton>\n  )\n}\n\nfunction RotatingIconButton({ children }) {\n  return <button>{children}</button>\n}\n```\n\nThis should give us something like this:\n\n<CodeBox>\n  <button>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </button>\n</CodeBox>\n\nOk, that's good for now. Let's move on to our button's styles.\n\n## Styling the Button\n\nBefore we get into our animations, let's first style up our button. By default, we want all of the button's children to be piled on top of one another in the center of the button.\n\nTo get this done, I'll create our first styled component, `Button`.\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n`\n```\n\nNext, I'll create a second component, `Icon`, that we'll use to wrap our icons.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`\n```\n\nAnd now let's put these pieces together in the `RotatingIconButton` component.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  return (\n    <Button>\n      {React.Children.map(children, (child, i) => {\n        return <Icon>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe should end up with a big pile of centered icons in the middle of our button:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonSimple>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonSimple>\n</CodeBox>\n\nNow let's work out our button's state.\n\n## The Button State\n\nOut button can have any number of children but we only want it to show one child at a time. The button will need to keep track of which of these children is its _currently active_ child.\n\nWe can create this state using the `useState` React hook, and we'll store the array index of the button's currently active child. As we render each child, we can compare its index against this value to see whether that child is the currently active one.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  const [current, setCurrent] = React.useState(0)\n\n  return (\n    <Button>\n      {React.Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return <Icon key={i}>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe're not using this `isCurrent` variable yet, but we'll come back to it soon.\n\nEach time we click the button, we'll want to bump up that `current` value so that it cycles through the children. In our click event handler, we'll also need to check whether we're already at our last index (`children.length - 1`) so that we can loop back around to zero when we've reached the end.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  const [current, setCurrent] = React.useState(0)\n\n  function cycleCurrent() {\n    if (current === children.length - 1) {\n      setCurrent(0)\n    } else {\n      setCurrent(current + 1)\n    }\n  }\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {React.Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return <Icon key={i}>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe now have everything we need to animate our icons.\n\n## Animating the Icons\n\nOn each render, we want our icons to perform two different animations depending on whether that icon is active or not.\n\nIf the icon is our new currently active icon, we want it to move from below the button up to the center of the button. If not, we'll instead want it to move from the center of the button to up above the button; or, if it's already above the button, to stay where it is.\n\nWe'll use the Icon element's `transfrom` property to make these moves, but we have two options for how to actually animate the element: the `transition` property and the `animation` property.\n\nLet's look at `transition` first.\n\n### Animating with Transition\n\nThe `transition` property allows us to define an animation to apply whenever certain properties change. In React, we can define a different `transform` value on each update based on `isCurrent`.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return (\n          <Icon\n            key={i}\n            style={{\n              transition: \"transform .5s\",\n              transform: `translateY(${isCurrent ? 0 : -100}%)`,\n            }}\n          >\n            {child}\n          </Icon>\n        )\n      })}\n    </Button>\n  )\n}\n```\n\nHere's what that code (with its snips unsnipped) will give us:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithTransition>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithTransition>\n</CodeBox>\n\nThat's admittedly funâ€”but it isn't what we wanted. Rather than everything moving in and out from the top, we wanted the new active icon to come in from the bottom.\n\nThis is a problem for the `transition` property. It doesn't give us a way to \"jump\" to our \"from\" position before transitioning to our \"to\" position, so we've have no way of getting from above to below without crossing back down through the middle. We could do some clever tricks here with effect hooks, `requestAnimationFrame`, and timings... but we don't have to.\n\nWe can use CSS animations instead.\n\n### Animating with CSS Animations\n\nTo use a CSS animation, we'll first need to define the animation as a set of keyframes.[^2] For this animation, we need two sets of keyframes: `riseIn` will move an element from a lower position to its default position; and `riseOut` will move the element from its default position to a higher position.\n\n```jsx\nimport styled, { keyframes } from \"styled-components\"\n\nconst riseIn = keyframes`\n  from {\n    transform: translateY(100%);\n  }\n  to {\n    transform: translateY(0%);\n  }\n`\n\nconst riseOut = keyframes`\n  from {\n    transform: translateY(0%);\n  }\n  to {\n    transform: translateY(-100%);\n  }\n`\n```\n\nNow we can modify our `Icon` styled component to use these animations. We'll pass the `Icon` component a new prop, `isCurrent`, that will determine which animation it should use.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation-fill-mode: forwards;\n  animation-name: ${(props) => (props.isCurrent ? riseIn : riseOut)};\n`\n```\n\nLet's see how that looks:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimation>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimation>\n</CodeBox>\n\nIt may still look a little strange, but if we hide the overflow on the button...\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n  overflow: hidden;\n`\n```\n\nThen we get this:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimationNoOverflow>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimationNoOverflow>\n</CodeBox>\n\nThere we go! We have our animation.\n\n## Final Touches\n\nThere are a few last details to take care of before I'll call this done.\n\nFirst, let's style up our button, getting rid of its background and border and giving it a hover effect.\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n  overflow: hidden;\n  cursor: pointer;\n  outline: none;\n  border-radius: 4px;\n  background: transparent;\n  border: none;\n\n  &:hover {\n    background: rgba(144, 144, 144, 0.1);\n  }\n`\n```\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimationFinal>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimationFinal>\n</CodeBox>\n\nThough it's probably hard to tell this deep into the article, we also need to work out how we handle our animations when the component first loads. On this first render, we don't want _any_ of our animations to fire.\n\nTo fix this, we'll need to keep track of whether we're in our first render. For this, we can use a `useRef` hook together with a `useEffect` hook that sets the ref's value back to false after the initial render.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  const isInitial = React.useRef(true)\n\n  React.useEffect(() => {\n    isInitial.current = false\n  }, [])\n\n  return <Button onClick={cycleCurrent}>{/* snip */}</Button>\n}\n```\n\nTo make use of this value, we'll give our `Icon` component one more prop, `isInitial`, that sets its animation duration to zero when `isInitial` is true.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation-fill-mode: forwards;\n  animation-duration: ${(props) => (props.isInitial ? 0 : 400)}ms;\n  animation-name: ${(props) => (props.isCurrent ? riseIn : riseOut)};\n`\n```\n\nAnd finally we can pass `isInitial` in through the `Icon`'s props.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  const isInitial = React.useRef(true)\n\n  React.useEffect(() => {\n    isInitial.current = false\n  }, [])\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return (\n          <Icon key={i} isInitial={isInitial} isCurrent={isCurrent}>\n            {child}\n          </Icon>\n        )\n      })}\n    </Button>\n  )\n}\n```\n\n## Final Component\n\nAnd that's it! Here it is, our final component in a sandbox:\n\n<CodeSandbox url=\"festive-fog-hnnqy\" />\n\nNow this isn't _exactly_ how I implemented my theme switching button on this blog, but it's the basic idea. To make it work for your site, you might have to pass along events to your button through its props, especially if you plan on doing more with clicks than just switching the icon. Alternatively, you could use custom hooks inside of the component to control a theme or update the `current` state if the theme changed from elsewhere.\n\nIf the tricky part was just the animation, then you should be good to go.\n\nThanks for reading, and good luck!\n\n[^1]: A cousin of the microinteraction is something I like to call the \"fidget interaction\", like the famous [chat room gem](https://diablo.fandom.com/wiki/Chat_Gem) in the Diablo video game. While microinteractions tend to reward or acknowledge certain user behaviors, fidget interactions are pointless: they don't _do_ anything except give us something to do. Try hovering over the black box at the top left of the header.\n[^2]: We could define these keyframes in a CSS file and just reference these animations by name, but since we're already using styled-components, let's stick to its way of handling keyframes. For the regular approach, see MDN's excellent guide to [Using CSS Animations](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations).\n","date":1599606000000,"data":{"title":"Making a Rotating Icon Button in React","date":"Wednesday, 9 September 2020","hero":"/images/anastasia-taioglou-EEDLURXCpqg-unsplash.jpg","status":"published","description":"A tutorial on building my this blog's theme-switching microinteraction."}}]}