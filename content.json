{"pages":[{"slug":"about","content":"\nMy name is Steve Ruiz and I'm a developer and interaction designer in London, currently working with creative tools. I build lots of prototypes. Sometimes those prototypes turn into products.\n\n## My Work\n\nI'm currently focusing on [tldraw](https://tldraw.com), a white-boarding application and an [engine](https://github.com/tldraw/tldraw) for applications that render React components onto a canvas interface. You can [sponsor my work](https://github.com/sponsors/steveruizok) on Github!\n\nI've previously worked with [Play](https://www.createwithplay.com/), helping to design a mobile-first design application for iOS. Before that, I was creating educational content for [Framer](https://framer.com/) and a user experience architect at [Inviqa](https://inviqa.com/). I've also worked with [ClearScore](https://www.clearscore.com/), [Phenomen Films](https://www.phenomentrust.org/), and plenty of shorter contracts, too.\n\n## Open Source\n\nI maintain a few open source projects:\n\n- [tldraw](https://tldaw.com/) is a tiny little drawing app.\n- [perfect-freehand](https://github.com/steveruizok/perfect-freehand) is a library for drawing freehand lines.\n- [perfect-arrows](https://github.com/steveruizok/perfect-arrows) is a library for drawing arrows between points and shapes. It made for some fun [tweet threads](https://twitter.com/steveruizok/status/1283139008499986437).\n- [state-designer](https://state-designer.com/) is a state management library with its own [visual design environment](https://ide.state-designer.com/). It's based on state charts and is great for prototyping.\n\n## Education\n\nI have my Masters degree in Fine Art from the University of Chicago. If you're curious, you can see more of my artwork [here](https://steveruizart.com).\n\n## Contact\n\nThe best way to contact me is on [twitter](https://twitter.com/steveruizok).\n","data":{"title":"About"},"index":0},{"slug":"archive","content":"","data":{"title":"Archive"},"index":1},{"slug":"index","content":"","data":{},"index":2}],"posts":[{"index":0,"slug":"perfect-dragging","content":"\nI recently started writing a post about [snapping](https://twitter.com/steveruizok/status/1449866480401764359) but realized I needed to write a post about dragging first.\n\n<Tweet id=\"1449866480401764359\" />\n\nIn this post, I'm going to quickly cover how to drag a shape on a canvas, or in an application that uses some kind of [zoom ui](/posts/zoom-ui). While it may seem obvious, implementing dragging in the wrong way means that other features, such as snapping, will become much more difficult to implement later on. It's worth getting it right the first time!\n\n> ðŸ‘‹ Just want to look at some code? [Click here](https://codesandbox.io/s/perfect-dragging-example-wg5u6) for the CodeSandbox.\n\n## Picking the Right Delta\n\nWhen a user drags a shape, its our job to calculcate the shape's new position based on whatever browser event we've received. On the web, this is usually a mouse move, touch move, or pointer move; but it could also be a scroll, pan, or zoom event, too.\n\n<img src=\"/images/dragging/dragging_3.png\" />\n\nMany applications calculate this new position by finding the pointer's movementâ€”the difference between the pointer's _current_ point and its _previous_ point)â€”and adding this to the shape's current position. While this works, it's a bad idea. :(\n\n<img src=\"/images/dragging/dragging_2.png\" />\n\nA far better idea is to calculate the shape's position by taking the pointer's deltaâ€”i.e. the difference between the pointer's _current_ point and the point where the drag _began_. We can then add this delta to the shape's _original_ position in order to find its new position.\n\n<img src=\"/images/dragging/dragging_1.png\" />\n\n## Why is this better?\n\nThere are several advantages to this approach:\n\n- You can implement a \"dead zone\" to prevent accidental drags.\n- You can update the position while scrolling during the drag.\n- You can restore a shape's position if the user cancels the drag.\n- You can freely adjust the delta with features like snapping, precision mode, or elastic bounds.\n\nIn later posts, I'll show how you could build these types of features on top of this strategy.\n\nUntil then, you'll have to trust me: in every case, the only way to implement these features is to _never_ rely on the shape's \"current\" position and _always_ compare against the shape's original position instead.\n\n## Example\n\nWant to see this in practice? Here's an [example]([https://codesandbox.io/s/perfect-dragging-example-wg5u6]) in React.\n\n<CodeSandbox url=\"perfect-dragging-example-wg5u6\" />\n","date":1634684400000,"data":{"title":"Perfect Dragging","date":"Wednesday, 20 October 2021","hero":"/images/dragging/dragging_1.png","status":"published","description":"How to drag shapes the right way. And yes, there is a wrong way! But trust me, this is the right way."}},{"index":1,"slug":"rotating-shapes","content":"\nEver notice in [Figma](https://figma.com) that if you rotate a few shapes and then rotate them back, they'll end up in a different place?\n\n<Figure\n  src=\"/images/rotating-shapes/figma-drift.mp4\"\n  alt=\"A video recorded from Figmashowing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nIt's not just Figma! [Excalidraw](https://excalidraw.com) supports this kind of rotation and has the same issue.\n\n<Figure\n  src=\"/images/rotating-shapes/excalidraw-drift.mp4\"\n  alt=\"A video recorded from Excalidraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\n...and so does my own project, [tldraw](https://tldraw.com), which is where I ran into the issue.\n\n<Figure\n  src=\"/images/rotating-shapes/tldraw-drift.mp4\"\n  alt=\"A video recorded from TLDraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nSide note: most other design tools don't support this kind of rotation. Shapes either rotate around their own centers or inherit rotation from a group. I wish they would though!\n\n<Figure\n  src=\"/images/rotating-shapes/pitch-rotation.mp4\"\n  alt=\"A video recorded from Excalidraw showing the change in position after rotating four selected shapes and then rotating them back.\"\n  isVideo\n/>\n\nAnyway, here's what's happening. When you start rotating a selection, you need to pick a point to rotate around. We're all using the average center of the selected shapesâ€”and we keep using this point until you stop rotating.\n\n<Figure\n  src=\"/images/rotating-shapes/center-rotate.mp4\"\n  alt=\"A video showing how selected shapes are rotated around their initial common center point.\"\n  isVideo\n/>\n\nHowever, the rotated shapes probably have a different average center; which means that your second rotation (ie to rotate things back) is pivoting around a different point. And that's what causes the change of position.\n\n<Figure\n  src=\"/images/rotating-shapes/new-centers.mp4\"\n  alt=\"A video showing how the selection's common center point changes when shapes are rotated.\"\n  isVideo\n/>\n\nHonestly, I was extremely glad to find this in Figma and other apps because I was worried it was a bug in my own rotation implementation.\n\nIt is even a bug though? It's weird that rotating a group and then rotating it back doesn't put them back in the same place. Let's fix it!\n\n<Figure\n  src=\"/images/rotating-shapes/tldraw-fixed.mp4\"\n  alt=\"A video from the tldraw app showing how the selection's common center point is preserved while the selection does not change.\"\n  isVideo\n/>\n\nAnd here's the fix: once a user starts a rotation, we hold onto the the center point; if the user rotates again, we re-use that same point; and we only give it up once the user makes a new selection.\n\n<Figure\n  src=\"/images/rotating-shapes/canva-fixed.mp4\"\n  alt=\"A video from the Canva app showing how the selection's common center point is preserved while the selection does not change.\"\n  isVideo\n/>\n\nTo their credit, [canva](https://canva.com) seems to be solving the problem is the same way. The original rotation point is preserved until a user makes a new selection.\n\nOk, that's it! Hope you enjoyed this extra-obscure edition of design tool micro-UX. If you catch any rotation-related bugs in [tldraw](https://tldraw.com), let me know!\n\n---\n\nLook familiar? This blog post was adapted from my [Twitter thread](https://twitter.com/steveruizok/status/1439581543480152069).\n\n<Tweet id=\"1439581543480152069\" />\n","date":1632006000000,"data":{"title":"Fixing the Drift in Shape Rotations","date":"Sunday, 19 September 2021","hero":"/images/rotating-shapes/hero.png","status":"published","description":"A look at an obscure bug common to drawing programs, where rotations can cause shapes to move to new positions."}},{"index":2,"slug":"pencil-tool","content":"\nEver wonder why regular pencil tools wait until after you finish drawing to smooth out your line? It's usually because the app is using a line-simplification algorithmâ€”and these sorts of algorithms aren't \"stable\" as a line is changing.\n\n<Figure\n  src=\"/images/pencil-ux/simplify-while-drawing.mp4\"\n  alt=\"A video showing a simplified line moving as a user writes the word hey.\"\n  isVideo\n/>\n\nHere's the algorithm at work, picking new points on almost every frame. Each solution is \"correct\" for each set of points but it is overall \"incorrect\" in the sense that the solutions keep changing! Try it out [here](https://codesandbox.io/s/simplified-too-often-xhpnr?file=/src/index.js).\n\n<Figure\n  src=\"/images/pencil-ux/simplify-hey-dots.mp4\"\n  alt=\"A video showing the simplified line's points as dots.\"\n  isVideo\n/>\n\nWhy simplify at all? The \"raw\" input points are often very jerky and noisy.\n\n<Figure\n  src=\"/images/pencil-ux/rough-hey-dots.mp4\"\n  alt=\"A video showing the drawing's unfiltered input points as dots.\"\n  isVideo\n/>\n\nThey don't make a very good looking line. Try it out [here](https://codesandbox.io/s/unfiltered-dots-kzgo3?file=/src/index.js).\n\n<Figure\n  src=\"/images/pencil-ux/rough-hey-line.mp4\"\n  alt=\"A video showing the drawing's unfiltered input points as a line.\"\n  isVideo\n/>\n\nWe can improve it a little by applying a low pass filter. (grey dots are the original points)\n\n<Figure\n  src=\"/images/pencil-ux/low-pass-hey-dots.mp4\"\n  alt=\"A video showing the drawing's input points as dots after a low-pass filter has been applied.\"\n  isVideo\n/>\n\nThe low-pass improves things a bit... (Try it out [here](https://codesandbox.io/s/low-pass-qvun5?file=/src/index.js))\n\n<Figure\n  src=\"/images/pencil-ux/low-pass-hey.mp4\"\n  alt=\"A video showing the drawing's input points as a line after a low-pass filter has been applied.\"\n  isVideo\n/>\n\nBut it's still a lot of data, especially if you're expecting to edit the points after the fact. So why not just wait until the end to simplify? The line doesn't change while the user draws and we get the result we want at the end, too. Try it out [here](https://codesandbox.io/s/agitated-knuth-k1dwm?file=/src/index.js).\n\n<Figure\n  src=\"/images/pencil-ux/rough-then-smooth.mp4\"\n  alt=\"A video showing the drawing's input points as a line during the drawing, then applying a simplify filter when it is completed.\"\n  isVideo\n/>\n\nIf you're in a design tool, then waiting until the end is probably fineâ€”but it's not a great experience for drawing or writing. So one of the big challenges in [perfect-freehand](https://github.com/steveruizok/perfect-freehand) was coming up with a \"stable\" way to simplify lines.\n\n<Figure\n  src=\"/images/pencil-ux/freehand-final.mp4\"\n  alt=\"A video showing the drawing's as a polygon rendered with perfect-freehand.\"\n  isVideo\n/>\n\nYou can see it at work on the corners of this curveâ€”first with the smoothing at minimum, and then with it turned up. (Try it [here](https://codesandbox.io/s/freehand-y1ihm?file=/src/index.js))\n\n<Figure\n  src=\"/images/pencil-ux/freehand-curves.mp4\"\n  alt=\"A video showing the perfect-freehand drawing simplifying points along a curve.\"\n  isVideo\n/>\n\nThis is still something I'm working on in the perfect-freehand algorithm. If you have any ideas, let me know. Or [dive into the code](https://github.com/steveruizok/perfect-freehand)!\n\n---\n\nLook familiar? This blog post was adapted from my [Twitter thread](https://twitter.com/steveruizok/status/1438847842261549061).\n\n<Tweet id=\"1438847842261549061\" />\n","date":1631833200000,"data":{"title":"Smooth Lines for Pencil Tools","date":"Friday, 17 September 2021","hero":"/images/pencil-ux/hero.png","status":"published","description":"A dive of medium depth into why pencil tools work the way they doâ€”and how they can be improved."}},{"index":3,"slug":"zoom-ui","content":"\nIf you've used apps like Photoshop, Figma, or even Google Maps, then you're probably familiar with a \"zoom UI\". This pattern lets a user explore a \"canvas\" of content by panning around the canvas or zooming in on a specific point.\n\nIn this article, I'll walk through everything involved in implementing the pattern using an infinite canvas. I'll be using TypeScript and React as my example implementations. The concepts are generic and you should be able to apply them to whatever environment, language or framework you like best.\n\n> ðŸ‘‹ Just want to look at some code? [Click here](https://codesandbox.io/s/zoom-ui-example-ep0cf) for the CodeSandbox.\n\n# Core Concepts\n\nLet's start with some core concepts.\n\n![](/images/zoom-ui/camera-viewport-canvas.jpg \"A diagram showing the relationship between the canvas, the camera, and the viewport.\")\n\nThe first is the **canvas**. You can think of this as a fixed plane of infinite dimensions. In a creative app, the canvas holds the user's artboards, shapes or other content.\n\nSuspended in front of this plane is the **camera**. It points at the canvas.\n\nThe **screen** is where we see what the camera sees.\n\nThe **viewport** is the part of the canvas that is visible on the screen.\n\n![](/images/zoom-ui/viewport-screen.jpg \"A diagram showing the relationship between the canvas, the camera, and the viewport.\")\n\nNote that the viewport is not centered around the camera. Instead, the viewport extends _down\nand right_ from the camera.\n\nThe camera can move in three dimensions: the camera's **point** is its position along the horizontal and vertical axes; its **zoom** is its position relative to the canvas. As the camera moves, the viewport will change to reflect the new visible part of the canvas.\n\n## Converting between Screen and Canvas\n\nA zoom UI has two coordinate systems: **screen coordinates** and **canvas coordinates**. A certain point on the screen will always refer to a certain point on the canvas. The actual canvas point will depend on the camera's point and zoom.\n\nIf we model a point like this:\n\n```ts\ninterface Point {\n  x: number\n  y: number\n}\n```\n\nAnd our camera like this:\n\n```ts\ninterface Camera {\n  x: number\n  y: number\n  z: number\n}\n```\n\nThen we can turn a screen point into a canvas point like this:\n\n```ts\nfunction screenToCanvas(point: Point, camera: Camera): Point {\n  return {\n    x: point.x / camera.z - camera.x,\n    y: point.y / camera.z - camera.y,\n  }\n}\n```\n\nAnd likewise, we can turn a canvas point into a screen point:\n\n```ts\nfunction canvasToScreen(point: Point, camera: Camera): Point {\n  return {\n    x: (point.x + camera.x) * camera.z,\n    y: (point.y + camera.y) * camera.z,\n  }\n}\n```\n\n**Note**: In our model, a zoom of `1` is equal to a 100% zoom.\n\n## Finding the Viewport\n\nThe viewport is a box that represents which part of the canvas is shown on the screen. Its values refer to canvas points. To find the viewport, we construct a box by converting the upper left and bottom right points of the screen into their corresponding canvas points.\n\nIf we define a box as:\n\n```ts\ninterface Box {\n  minX: number\n  minY: number\n  maxX: number\n  maxY: number\n  width: number\n  height: number\n}\n```\n\nThen we can find our viewport box like this:\n\n```ts\nfunction getViewport(camera: Camera, box: Box): Box {\n  const topLeft = screenToCanvas({ x: box.minX, y: box.minY }, camera)\n  const bottomRight = screenToCanvas({ x: box.maxX, y: box.maxY }, camera)\n\n  return {\n    minX: topLeft.x,\n    minY: topLeft.y,\n    maxX: bottomRight.x,\n    maxY: bottomRight.y,\n    height: bottomRight.x - topLeft.x,\n    width: bottomRight.y - topLeft.y,\n  }\n}\n```\n\nIn a full screen browser app, we could find the viewport like this:\n\n```ts\nconst viewport = getViewport(camera, {\n  minX: 0,\n  minY: 0,\n  maxX: window.innerWidth,\n  maxY: window.innerHeight,\n  width: window.innerWidth,\n  height: window.innerHeight,\n})\n```\n\nOr, if our canvas was part of a webpage, we could find the viewport using its `DOMRect`. Note that in this case, scrolling would change the \"screen box\".\n\n```ts\nconst rect = document.body.getBoundingClientRect()\n\nconst viewport = getViewport(camera, {\n  minX: rect.left,\n  minY: rect.top,\n  maxX: rect.right,\n  maxY: rect.bottom,\n  width: rect.width,\n  height: rect.height,\n})\n```\n\n## Panning and Zooming\n\nWhen the camera moves along the horizontal or vertical axes, we call this movement a \"pan\". To model a pan, we adjust the camera's point by the delta in either direction. And to make the pan feel consistent, we divide the deltas by the camera's zoom.\n\n```ts\nfunction panCamera(camera: Camera, dx: number, dy: number): Camera {\n  return {\n    x: camera.x - dx / camera.z,\n    y: camera.y - dy / camera.z,\n    z: camera.z,\n  }\n}\n```\n\nWhen the camera moves toward or away from the canvas, we call this movement a \"zoom\". In our model, we also need to provide a canvas point that the camera is \"zooming toward\". Again, to make our zoom feel consistent, we adjust the zoom delta based on the current zoom.\n\n```ts\nfunction zoomCamera(camera: Camera, point: Point, dz: number): Camera {\n  const zoom = camera.z - dz * camera.z\n\n  const p1 = screenToCanvas(point, camera)\n\n  const p2 = screenToCanvas(point, { ...camera, z: zoom })\n\n  return {\n    x: camera.x + (p2.x - p1.x),\n    y: camera.y + (p2.y - p1.y),\n    z: zoom,\n  }\n}\n```\n\n## Capturing Events\n\nIn the browser, both zoom and pan events come from wheel events. By convention, we use the control key to identify a zoom. A user's device will sometimes follow this convention automatically: for example, on a MacBook trackpad, pinching will fire a WheelEvent with `ctrlKey: true`.\n\n```ts\nfunction handleWheel(event: WheelEvent) {\n  event.preventDefault()\n\n  const { clientX: x, clientY: y, deltaX, deltaY, ctrlKey } = event\n\n  if (ctrlKey) {\n    setCamera((camera) => zoomCamera(camera, { x, y }, deltaY / 100))\n  } else {\n    setCamera((camera) => panCamera(camera, deltaX, deltaY))\n  }\n}\n```\n\nSet this event on the `document.body` or the zoom UI's root container.\n\n> In the browser, wheel events often cause other changes such as scrolls or browser-level zooms. Calling `event.preventDefault()` prevents these actions. On mobile devices, you may need to cancel other touch or gesture events to avoid native behaviors.\n\nIn a React app, you might use a hook like this:\n\n```tsx\nReact.useEffect(() => {\n  const elm = ref.current\n\n  if (!elm) return\n\n  elm.addEventListener(\"wheel\", handleWheel, { passive: false })\n\n  return () => elm.removeEventListener(\"wheel\", handleWheel)\n}, [ref])\n```\n\n## Shortcuts\n\nOften you'll also want to have shortcuts for zooming in and out toward the center of the viewport.\n\n```ts\nfunction zoomCameraTo(camera: Camera, point: Point, zoom: number): Camera {\n  const p1 = screenToCanvas(point, camera)\n\n  const p2 = screenToCanvas(point, { ...camera, z: zoom })\n\n  return {\n    x: camera.x + (p2.x - p1.x),\n    y: camera.y + (p2.y - p1.y),\n    z: zoom,\n  }\n}\n```\n\nTo zoom in increments of 25%:\n\n```ts\nfunction zoomIn(camera: Camera): Camera {\n  const i = Math.round(camera.z * 100) / 25\n\n  const nextZoom = (i + 1) * 0.25\n\n  const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 }\n\n  return zoomCameraTo(camera, center, camera.z - nextZoom)\n}\n```\n\n```ts\nfunction zoomOut(camera: Camera): Camera {\n  const i = Math.round(camera.z * 100) / 25\n\n  const nextZoom = (i - 1) * 0.25\n\n  const center = { x: window.innerWidth / 2, y: window.innerHeight / 2 }\n\n  return zoomCameraTo(camera, center, camera.z - nextZoom)\n}\n```\n\nAnd to reset the zoom:\n\n```ts\nfunction resetZoom(camera: Camera): Camera {\n  return zoomCamera(camera, center, camera.z - 1)\n}\n```\n\n## Applying the Camera\n\nIn the browser, the best way to apply a zoom is through CSS transforms.\n\n```ts\nconst transform = `\n  scale(${camera.z}) \n  translate(${camera.x}px, ${camera.y}px)\n`\n```\n\n> Remember that _order matters_ when writing a transform. In this case, the order is: first scale, then translate.\n\nIf you're using canvas, then you can translate the canvas instead.\n\n```ts\nctx.scale(camera.z, camera.z)\nctx.translate(camera.x, camera.y)\n```\n\n## Conclusion\n\nThat's the basics of a zoom UI. Many zoom UIs will also have the option to zooming to content or to selected content, but those functions will be different depending on how the rest of your app is set up.\n\nHere's a [CodeSandbox](https://codesandbox.io/s/zoom-ui-example-ep0cf) showing an SVG implementation for all of the code in this article.\n\nHere's a [CodeSandbox](https://codesandbox.io/s/zoom-ui-example-canvas-6j3wo) showing the same implementation with HTML canvas.\n\nEnjoy!\n","date":1628118000000,"data":{"title":"Creating a Zoom UI","date":"Thursday, 5 August 2021","hero":"/images/zoom-ui/brazil-topno-qvLhmpWIA2Y-unsplash.jpg","status":"published","description":"All the code you need to control a camera in a zoom-able, pan-able UI for an infinite canvas."}},{"index":4,"slug":"how-to-filter-an-object","content":"\nEver need to filter properties from an object? Here's how to do it.\n\nIn JavaScript:\n\n```js\nfunction filterObject(obj, fn) {\n  return Object.fromEntries(Object.entries(obj).filter(fn))\n}\n```\n\nIt's a bit trickier in TypeScript:\n\n```ts\ntype Entry<T> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T]\n\nfunction filterObject<T extends object>(\n  obj: T,\n  fn: (entry: Entry<T>, i: number, arr: Entry<T>[]) => boolean\n) {\n  return Object.fromEntries(\n    (Object.entries(obj) as Entry<T>[]).filter(fn)\n  ) as Partial<T>\n}\n```\n\nIn either case, we can use our `filterObject` helper to return a new copy of an object with certain keys removed. Our filter function works just like `Array.filter`, except that its callback function's first parameter will be the property's key value pair as array (`[key, value]`).\n\n```ts\nconst author = { name: \"Steve\", age: 93, height: 241 }\n\nconst onlySteves = filterObject(author, ([k, v]) => v === \"Steve\")\n// { name: \"Steve\" }\n\nconst onlyNumbers = filterObject(author, ([k, v]) => typeof v === \"number\")\n// { age: 93, height: 241 }\n\nconst onlyNames = filterObject(author, ([k, v]) => k === \"name\")\n// { name: \"Steve\" }\n```\n\n### Older Browsers\n\nIf you wanted to do this by hand (or perhaps in older browsers without polyfills for `Object.fromEntries` and `Object.entries`), you could also do it this way: create a shallow copy of the object, iterate once to generating the entries, and then iterate again to `delete` filtered properties.\n\n```ts\nfunction filterObject2<T extends object>(\n  obj: T,\n  fn: (entry: Entry<T>, i: number, arr: Entry<T>[]) => boolean\n): Partial<T> {\n  const next = { ...obj }\n\n  const entries: Entry<T>[] = []\n\n  for (const key in obj) {\n    entries.push([key, obj[key]])\n  }\n\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i]\n    if (!fn(entry, i, entries)) {\n      delete next[entry[0]]\n    }\n  }\n\n  return next\n}\n```\n\nEnjoy!\n","date":1627945200000,"data":{"title":"Filtering an Object in TypeScript","date":"Tuesday, 3 August 2021","hero":"/images/stephanie-leblanc-JLMEZxBcXCU-unsplash.jpg","status":"published","description":"How to filter properties from an object."}},{"index":5,"slug":"it-wasnt-made-to-do-that","content":"\nThis week [Figma](https://figma.com) launched their [Interactive Components ](https://help.figma.com/hc/en-us/articles/360061175334-Create-interactive-components-with-Variants) feature in beta. The response from the design community has been uh, surprising.\n\n<Tweet id=\"1367501450683834372\" />\n\nThe feature was probably designed with problems like these in mind:\n\n<Tweet id=\"1366830065468768261\" />\n\nThat hasn't stopped designers from filling my timeline with incredible, bizarre prototypes like this:\n\n<Tweet id=\"1366677421001502721\" />\n\n...and this:\n\n<Tweet id=\"1366041396092755970\" />\n\n...and even this:\n\n<Tweet id=\"1366520489578016775\" />\n\nPrototypes like these beg the question... why?\n\nOr, more specifically, **why make this in Figma?**\n\nPersonally, I'm a big fan of making stuff with the wrong tools. Projects like [Poom](https://freds72.itch.io/poom) inspire me. A long time ago, I made a kind of [Minecraft game in Framer](https://framer.cloud/TDhUi/).\n\nPushing constraints and building wild prototypes is fun, but Figma is a special case because its prototypes don't work like anything else. To learn more about why these new protoypes are exciting (or ridiculous, depending on your perspective) let's go back and look at how we got here.\n\n## Draw a Noodle\n\nIn 2017, Figma [released](https://www.figma.com/blog/figma-2-0-now-with-prototyping-and-developer-handoff/) its first set of prototyping features. It worked like this: select Frame A, draw an arrow to Frame B; and then in the preview mode, interact with Frame A to transition to Frame B.\n\n![Drawing a Noodle in Figma](/images/figma-noodle.gif)\n\nWhile the team has continued adding to this part of the app, it hasn't changed much. Prototyping in Figma has always been about **creating links between Frames**.\n\nIn fall of 2020, Figma released [Component Variants](https://www.figma.com/best-practices/creating-and-organizing-Variants/), a new feature that lets a designer create related snapshots of a Component.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-0.png\"\n  alt=\"Component Variants in Figma.\"\n/>\n\nInteractive Components brings prototyping to Component Variants, allowing a designer to **create links between Variants**.\n\n<Figure\n  src=\"/images/figma-interaction.gif\"\n  alt=\"Drawing a link between component Variants.\"\n/>\n\nIt works pretty much the same way: select Variant A, draw an arrow to Variant B; and then in the preview mode, interact with Variant A to transition _the Component_ to Variant B.\n\nTo learn why this change matters so much, let's first look at some of the problems with Figma's prototyping model.\n\n## Noodle Problems\n\nFigma's prototyping model was always good for simple click-through prototypes but it struggled with anything complex. This is because, before Interactive Components, Figma's prototype only kept track of the user's current Frame.[^1]\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-0.svg\"\n  alt=\"A diagram showing three Frames in Figma, with Home as the current Frame.\"\n/>\n\nClicking a link would change the current Frame.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-1.svg\"\n  alt=\"A diagram a link to News, with News as the new current Frame.\"\n/>\n\nAnd that was pretty much it. Building a prototype like this was easy to learn and easy to use. But it had two problems.\n\n### Problem 1: Lots of Noodles\n\nEven a small prototype has lots of links, each of which would need to be created by hand.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-a-2.svg\"\n  alt=\"A diagram showing all of the possible links.\"\n/>\n\nThere were some tricks to reduce the number of links, such as using the \"Back\" transition target or setting your links on a Component and then reusing that Component between Frames, but there was really no escaping it: prototyping in Figma meant drawing lots and lots of arrows.\n\nAnd while [I really like drawing arrows](https://github.com/steveruizok/perfect-arrows), needing to draw so many arrows made it extremely tedious to prototype even a medium-sized project in Figma.\n\n### Problem 2: Compound Noodles\n\nThere was a bigger problem, however.\n\nReal apps keep track of lots of information that describes the current \"state\" of the app. Navigation is often only a small part of that state. An app's state might also hold information such as the current user's name, their preferences and settings, or the contents of their shopping cart.\n\nBy comparison, a Figma prototype's state included _one_ piece of information: the user's current Frame.\n\nThis meant that a designer looking to model _other_ types of state, such as whether the user is in a \"light mode\" or \"dark mode\", would have to somehow achieve this complexity with only that single property to work with.\n\nThe solution? **Create a Frame for every possible state combination**.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-0.svg\"\n  alt=\"A diagram showing six Frames: three for light mode and three for dark mode.\"\n/>\n\nOnce a designer had modeled each state as its own Frame, a user could \"change the state\" by linking to a version that showed the correct configuration.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-1.svg\"\n  alt=\"A diagram showing six Frames: three for light mode and three for dark mode.\"\n/>\n\nAs you can imagine, this doesn't mix well with the first problem.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-2.svg\"\n  alt=\"A diagram showing 18 arrows between the six Frames.\"\n/>\n\nDifferent _kinds_ of state could make the problem even worse.\n\nAdding a \"dusk\" mode would require yet another duplication, or three more Frames, which is bad enough. But adding a _parallel_ state, such as \"logged in\", would mean duplicating the entire collectionâ€”so six more states on top of the original six, with even more arrows for each.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-b-3.svg\"\n  alt=\"A diagram showing 18 arrows between the six Frames.\"\n/>\n\nGiven enough time and coffee, I could in theory prototype a working game of checkers in Figma using only links between Framesâ€”but it would require about 500 quintillion Frames to do it, and an even greater number of links.\n\nMore realistically, once I'd built a medium-sized prototype with both light mode, dark mode, and an authentication state, I would never again change that design. Whatever I'd wired up would ship, sorry.\n\n### Enter Interactive Components\n\nGiving each Component its own state means freeing that \"current Frame\" state from its extra duties, greatly reducing the number of Frames needed to model states other than the user's actual navigation.\n\nWhile [@mingyaaa](https://twitter.com/mingyaaa)'s [game of Go](https://www.figma.com/community/file/948345806178418685) would previously have required 10<sup>172</sup> Frames (a number far greater than the number of atoms in the universe), Ming-ya could do it with just four Components, each with four Variants and a simple set of links.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-c-0.png\"\n  alt=\"A screenshot of a Figma file showing four Components.\"\n/>\n\nThe fundamental problem hasn't changed: modeling a Component with multiple properties still means creating different Variants for each combination of the Component's properties. However, by pushing the problem down into Components, Interactive Components greatly reduces the number of combinations.\n\nPrototypes that were impossible (or impractical) before are now comparitively easy to put together. That's good for everyone.\n\n## Prototyping Anything?\n\nWhile Figma's Interactive Components do expand the field of what a designer can do in a Figma prototype, there are still some major limitations. Without the ability to store, refer to, or manipulate actual data like text, numbers, or values, designers will be limited to what can be fully represented through snapshots.\n\nFor example, Design XStream's [text input](https://www.figma.com/community/file/949319444934680661) has a \"Single Letter\" Component with Variants for each possible character. The input field is a row of 26 of these components. Pressing a key changes the Component's Variant to match the key that you've pressed.\n\n<Figure\n  src=\"/images/it-wasnt-made-for-that/figma-d-0.png\"\n  alt=\"A screenshot of the Single Character Component, showing interactions.\"\n/>\n\nIn other words, Figma isn't actually storing the text you type; it's just changing the Variant of each of those Components. There's no way to use that data outside of the component.\n\n## Fun with Prototypes\n\n<Tweet id=\"1367024814062530560\" />\n\nOk, so prototyping in Figma isn't perfect. But as these prototype show, you _can_ do a lot with Interactive Components. While I'll still use other tools for more serious prototyping, Figma's limitations do make for some excellent creative constraints.\n\nInteractive Components might not have been meant to make text inputs or games, but when you give talented people simple tools to use, they can make some pretty amazing things. And I _am_ sure that the feature was made to be funâ€”and in that sense, mission accomplished!\n\n---\n\n[^1] Technically speaking, Figma also keeps track of the user's visited Frames. This \"navigation stack\" works like a stack of cards: clicking a link would add a new Frame to the stack, and going back would remove the current Frame from the stack. Whichever way you went, the Frame on top of the stack would always become the new current Frame.\n","date":1614902400000,"data":{"title":"Figma's Interactive Components Were Not Designed For This","date":"Friday, 5 March 2021","hero":"/images/figma-input.png","status":"published","description":"A survey of the bizarre prototypes designers can now make in Figma."}},{"index":6,"slug":"rotating-icon-button","content":"\nIf you haven't already, try changing the theme on this blog by clicking the button in the top right corner of the webpage. You'll notice a fun detail: as you cycle between the themes, the icons will \"rotate\" in from bottom to top.\n\nKinda cool, right?\n\nIn design, We call these little details _microinteractions_[^1]. Small, surprising and hopefully delightful, these animations can give an outsized amount of character to an otherwise boring, functional user interface.\n\nIn this post, I'll show you how to build a rotating icon button like mine in React. If you're just looking for the code, feel free to skip to the end or [click here](https://codesandbox.io/s/festive-fog-hnnqy?from-embed) for the code sandbox.\n\nOk, let's get started!\n\n## Setup\n\n> If you'd like to follow along, you can fork [this CodeSandbox](https://codesandbox.io/s/intelligent-goldwasser-z9szy?file=/src/App.js).\n\nLet's start by creating a new React app and adding our dependencies. For this article, I'll be using `styled-components` to handle styling and `react-feather` for icons. I'm going to use three icons: `Sun`, `CloudRain`, and `Moon`.\n\nWe'll also need a component for our button, `RotatingIconButton`. Our app is going to return this button with our three icons as its children.\n\n```jsx\nimport React from \"react\"\nimport { Sun, CloudRain, Moon } from \"react-feather\"\nimport styled from \"styled-components\"\n\nexport default function App() {\n  return (\n    <RotatingIconButton>\n      <Sun />\n      <CloudRain />\n      <Moon />\n    </RotatingIconButton>\n  )\n}\n\nfunction RotatingIconButton({ children }) {\n  return <button>{children}</button>\n}\n```\n\nThis should give us something like this:\n\n<CodeBox>\n  <button>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </button>\n</CodeBox>\n\nOk, that's good for now. Let's move on to our button's styles.\n\n## Styling the Button\n\nBefore we get into our animations, let's first style up our button. By default, we want all of the button's children to be piled on top of one another in the center of the button.\n\nTo get this done, I'll create our first styled component, `Button`.\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n`\n```\n\nNext, I'll create a second component, `Icon`, that we'll use to wrap our icons.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`\n```\n\nAnd now let's put these pieces together in the `RotatingIconButton` component.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  return (\n    <Button>\n      {React.Children.map(children, (child, i) => {\n        return <Icon>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe should end up with a big pile of centered icons in the middle of our button:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonSimple>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonSimple>\n</CodeBox>\n\nNow let's work out our button's state.\n\n## The Button State\n\nOut button can have any number of children but we only want it to show one child at a time. The button will need to keep track of which of these children is its _currently active_ child.\n\nWe can create this state using the `useState` React hook, and we'll store the array index of the button's currently active child. As we render each child, we can compare its index against this value to see whether that child is the currently active one.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  const [current, setCurrent] = React.useState(0)\n\n  return (\n    <Button>\n      {React.Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return <Icon key={i}>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe're not using this `isCurrent` variable yet, but we'll come back to it soon.\n\nEach time we click the button, we'll want to bump up that `current` value so that it cycles through the children. In our click event handler, we'll also need to check whether we're already at our last index (`children.length - 1`) so that we can loop back around to zero when we've reached the end.\n\n```jsx\nfunction RotatingIconButton({ children }) {\n  const [current, setCurrent] = React.useState(0)\n\n  function cycleCurrent() {\n    if (current === children.length - 1) {\n      setCurrent(0)\n    } else {\n      setCurrent(current + 1)\n    }\n  }\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {React.Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return <Icon key={i}>{child}</Icon>\n      })}\n    </Button>\n  )\n}\n```\n\nWe now have everything we need to animate our icons.\n\n## Animating the Icons\n\nOn each render, we want our icons to perform two different animations depending on whether that icon is active or not.\n\nIf the icon is our new currently active icon, we want it to move from below the button up to the center of the button. If not, we'll instead want it to move from the center of the button to up above the button; or, if it's already above the button, to stay where it is.\n\nWe'll use the Icon element's `transfrom` property to make these moves, but we have two options for how to actually animate the element: the `transition` property and the `animation` property.\n\nLet's look at `transition` first.\n\n### Animating with Transition\n\nThe `transition` property allows us to define an animation to apply whenever certain properties change. In React, we can define a different `transform` value on each update based on `isCurrent`.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return (\n          <Icon\n            key={i}\n            style={{\n              transition: \"transform .5s\",\n              transform: `translateY(${isCurrent ? 0 : -100}%)`,\n            }}\n          >\n            {child}\n          </Icon>\n        )\n      })}\n    </Button>\n  )\n}\n```\n\nHere's what that code (with its snips unsnipped) will give us:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithTransition>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithTransition>\n</CodeBox>\n\nThat's admittedly funâ€”but it isn't what we wanted. Rather than everything moving in and out from the top, we wanted the new active icon to come in from the bottom.\n\nThis is a problem for the `transition` property. It doesn't give us a way to \"jump\" to our \"from\" position before transitioning to our \"to\" position, so we've have no way of getting from above to below without crossing back down through the middle. We could do some clever tricks here with effect hooks, `requestAnimationFrame`, and timings... but we don't have to.\n\nWe can use CSS animations instead.\n\n### Animating with CSS Animations\n\nTo use a CSS animation, we'll first need to define the animation as a set of keyframes.[^2] For this animation, we need two sets of keyframes: `riseIn` will move an element from a lower position to its default position; and `riseOut` will move the element from its default position to a higher position.\n\n```jsx\nimport styled, { keyframes } from \"styled-components\"\n\nconst riseIn = keyframes`\n  from {\n    transform: translateY(100%);\n  }\n  to {\n    transform: translateY(0%);\n  }\n`\n\nconst riseOut = keyframes`\n  from {\n    transform: translateY(0%);\n  }\n  to {\n    transform: translateY(-100%);\n  }\n`\n```\n\nNow we can modify our `Icon` styled component to use these animations. We'll pass the `Icon` component a new prop, `isCurrent`, that will determine which animation it should use.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation-fill-mode: forwards;\n  animation-name: ${(props) => (props.isCurrent ? riseIn : riseOut)};\n`\n```\n\nLet's see how that looks:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimation>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimation>\n</CodeBox>\n\nIt may still look a little strange, but if we hide the overflow on the button...\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n  overflow: hidden;\n`\n```\n\nThen we get this:\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimationNoOverflow>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimationNoOverflow>\n</CodeBox>\n\nThere we go! We have our animation.\n\n## Final Touches\n\nThere are a few last details to take care of before I'll call this done.\n\nFirst, let's style up our button, getting rid of its background and border and giving it a hover effect.\n\n```jsx\nconst Button = styled.button`\n  height: 48px;\n  width: 48px;\n  position: relative;\n  padding: 0px;\n  overflow: hidden;\n  cursor: pointer;\n  outline: none;\n  border-radius: 4px;\n  background: transparent;\n  border: none;\n\n  &:hover {\n    background: rgba(144, 144, 144, 0.1);\n  }\n`\n```\n\n<CodeBox>\n  <RotatingIconButton.RotatingIconButtonWithCSSAnimationFinal>\n    <RotatingIconButton.Sun />\n    <RotatingIconButton.CloudRain />\n    <RotatingIconButton.Moon />\n  </RotatingIconButton.RotatingIconButtonWithCSSAnimationFinal>\n</CodeBox>\n\nThough it's probably hard to tell this deep into the article, we also need to work out how we handle our animations when the component first loads. On this first render, we don't want _any_ of our animations to fire.\n\nTo fix this, we'll need to keep track of whether we're in our first render. For this, we can use a `useRef` hook together with a `useEffect` hook that sets the ref's value back to false after the initial render.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  const isInitial = React.useRef(true)\n\n  React.useEffect(() => {\n    isInitial.current = false\n  }, [])\n\n  return <Button onClick={cycleCurrent}>{/* snip */}</Button>\n}\n```\n\nTo make use of this value, we'll give our `Icon` component one more prop, `isInitial`, that sets its animation duration to zero when `isInitial` is true.\n\n```jsx\nconst Icon = styled.div`\n  position: absolute;\n  top: 0px;\n  height: 100%;\n  width: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  animation-fill-mode: forwards;\n  animation-duration: ${(props) => (props.isInitial ? 0 : 400)}ms;\n  animation-name: ${(props) => (props.isCurrent ? riseIn : riseOut)};\n`\n```\n\nAnd finally we can pass `isInitial` in through the `Icon`'s props.\n\n```jsx\nexport function RotatingIconButton({ children }) {\n  /* snip */\n\n  const isInitial = React.useRef(true)\n\n  React.useEffect(() => {\n    isInitial.current = false\n  }, [])\n\n  return (\n    <Button onClick={cycleCurrent}>\n      {Children.map(children, (child, i) => {\n        const isCurrent = i === current\n\n        return (\n          <Icon key={i} isInitial={isInitial} isCurrent={isCurrent}>\n            {child}\n          </Icon>\n        )\n      })}\n    </Button>\n  )\n}\n```\n\n## Final Component\n\nAnd that's it! Here it is, our final component in a sandbox:\n\n<CodeSandbox url=\"festive-fog-hnnqy\" />\n\nNow this isn't _exactly_ how I implemented my theme switching button on this blog, but it's the basic idea. To make it work for your site, you might have to pass along events to your button through its props, especially if you plan on doing more with clicks than just switching the icon. Alternatively, you could use custom hooks inside of the component to control a theme or update the `current` state if the theme changed from elsewhere.\n\nIf the tricky part was just the animation, then you should be good to go.\n\nThanks for reading, and good luck!\n\n[^1]: A cousin of the microinteraction is something I like to call the \"fidget interaction\", like the famous [chat room gem](https://diablo.fandom.com/wiki/Chat_Gem) in the Diablo video game. While microinteractions tend to reward or acknowledge certain user behaviors, fidget interactions are pointless: they don't _do_ anything except give us something to do. Try hovering over the black box at the top left of the header.\n[^2]: We could define these keyframes in a CSS file and just reference these animations by name, but since we're already using styled-components, let's stick to its way of handling keyframes. For the regular approach, see MDN's excellent guide to [Using CSS Animations](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations).\n","date":1599606000000,"data":{"title":"Making a Rotating Icon Button in React","date":"Wednesday, 9 September 2020","hero":"/images/anastasia-taioglou-EEDLURXCpqg-unsplash.jpg","status":"published","description":"A tutorial on building my this blog's theme-switching microinteraction."}}]}